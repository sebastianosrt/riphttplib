
      - Add ALPN h3 properly by constructing a rustls
        config for QUIC (instead of platform verifier),
        if you want to ensure runtime interop

- Public API duplication and inconsistency:
    - Too many variants: send, send_bytes, send_str,
      send_string, etc. in H1/H3 clients. These should
      be unified behind generics/traits.
    - Target duplicates url, scheme, host, port, path
      and omits query when using Url::path(); Url
      parsing is unwrap()-based (brittle). See src/
      utils.rs:6–15.
- Error model lacks nuance and mapping:
    - ProtocolError flattens many domains; mapping to
      HTTP/2/HTTP/3 specific stream/connection errors
      is minimal.

Protocol Correctness

  - HTTP/1.1
      - Response parsing assumes UTF-8 everywhere and
        allows read-to-end when no length—can block until
        close.
  - HTTP/2
      - HPACK header handling assumes UTF-8 (see src/h2/
        framing.rs:146–173); consider lossy fallback or
        explicit error type.
      - Flow control updates are simplistic; max frame
        size and header continuation are assumed “fit
        into one frame” (see send_headers in src/h2/
        connection.rs:210–226).


  Transport & Stream Abstraction

  - StreamType tries to unify TCP/TLS/QUIC, but HTTP/3
    inherently uses bidirectional streams, not a single
    connection-as-IO:
      - H3 should manage quinn::Connection plus per-
        request SendStream/RecvStream pairs.
      - H1/H2 can share a unified AsyncRead + AsyncWrite
        transport. Consider splitting “connectors” from
        protocol logic.


  API Design & Ergonomics

  - Introduce a Request/Response model:
      - Replace the Protocol trait signature with a
        single request(&self, req: Request) -> Response
        or async method. Keep “freedom to craft invalid
        headers/frames” by allowing unchecked headers via
        a “raw” mode.
      - Use impl Into<Bytes> (or AsRef<[u8]>) for bodies
        to remove *_str, *_string, *_bytes duplication.
  - Target/URI:
      - Make parse_target return Result<Target, Error>
        instead of unwrap() (src/utils.rs:6–15).
      - Preserve query in the path (Url::path() drops ?
        query). Use url::Url::path() + query() to
        reconstruct path_with_query.
      - protocols: HashSet<HttpProtocol> in Target
        is unused—either drop it or implement ALPN/
        negotiation logic that consumes it.

  Error Handling

  - Expand ProtocolError:
      - Add typed variants for H2 (e.g., FrameSizeError,
        FlowControlError, CompressionError) and H3 (e.g.,
        H3MessageError, StreamCreationError, QpackError).
      - Provide From conversions (impl From<io::Error>)
        and error sources.
      - Map framed errors properly: RST_STREAM code
        mapping in H2 (already constants in src/h2/
        client.rs:7–21) should flow into the error type.
  - Timeouts and cancellations:
      - Add configurable timeouts for connect/read/write
        with tokio::time::timeout.

  HTTP/2 Improvements

  - Handle continuation frames when header blocks exceed
    max_frame_size.
  - Respect advertised remote settings, especially
    MAX_FRAME_SIZE, INITIAL_WINDOW_SIZE, and apply window
    changes to connection and streams.
  - Ensure ALPN is only h2 for HTTP/2 TLS connections
    (src/stream.rs:137–139 is correct) and that SNI
    matches.

  HTTP/1.1 Improvements

  - For requests without content-length/chunked, decide
    consistent behavior:
      - Either set Connection: close and shutdown the
        write side after body, or require chunked for
        request bodies unless user opts out.
  - Response parsing: be robust against status lines
    with extra whitespace; consider a stricter split that
    still accepts typical variants.

  Testing & Examples

  - Tests:
      - Only H1 and utils have tests. Add unit tests
        for H2/H3 framing encoders/decoders (pure, no
        network) and for connection state transitions.
      - Add property/fuzz tests for frame parse/serialize
        round-trips (H2/H3).
  - Examples:
      - H2 example compiles only when
        rustls::crypto::ring::default_provider() is set;
        note that in README and examples.
      - Add a minimal H3 example once per-stream routing
        is fixed.

  Tooling & Project Hygiene

  - Cargo edition:
      - edition = "2024" in Cargo.toml may not be
        available on older toolchains. If you need
        broader compatibility, use 2021 unless you rely
        on 2024-specific features.
  - CI and linting:
      - Add cargo clippy --all-targets --all-features -D
        warnings and cargo fmt -- --check.
      - Consider cargo-deny for deps and cargo-audit.
  - Features:
      - Add features for h1, h2, h3, insecure-tls,
        danger-frames to let users opt into risky
        behavior explicitly.
  - Documentation:
      - Expand README: safety caveats, feature flags,
        examples per protocol, and the “malformed frame”
        use-case.
  - Cleanup:
      - Remove stray src/mod.rs (empty) or use it
        intentionally.
      - Remove unused imports (e.g., RootCertStore,
        webpki_roots), or use them to install roots.

  Suggested Refactor Path (Incremental)

  - Step 3: API consolidation
      - Introduce Request and unify send* methods via
        impl Into<Bytes>. Keep raw/malformed mode via a
        builder toggle.
  - Step 4: Protocol maturity
      - H2: continuation frames, flow control polish,
        header size handling.
      - H3: proper stream routing, response reading per
        stream, GOAWAY behavior.
  - Step 5: Tests + tooling
      - Add framing tests, error mapping tests, clippy,
        fmt, minimal CI.

```
pub async fn create_stream(
    scheme: &str,
    host: &str,
    port: u16,
) -> io::Result<StreamType> {
    match scheme {
        "http" => create_tcp_stream(host, port).await,
        "https" => create_tls_stream(host, port, host).await,
        "h2" => create_h2_tls_stream(host, port, host).await,
        "h3" | "http3" => create_quic_connection(host, port, host).await,
        _ => Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!("Unsupported scheme: {}", scheme),
        )),
    }
}
```